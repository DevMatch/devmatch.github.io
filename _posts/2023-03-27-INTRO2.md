---
layout: post
title: "Introduction"
date:   2019-01-20 23:45:29 -0800
categories: docs
---

# DevMatch engineering challenges

The DevMatch platform helps you to host short (1-hour) engineering challenges. These challenges are meant to be representative of day to day activities of a software engineer. There are [plenty of examples](https://www.trytapioca.com/library-of-assessments) of these challenges out there that you can borrow inspiration from. 

DevMatch grabs concepts from competitive programming. You provide a statement to the participant and sometimes a starting point, like a pre-existing code repository. Then, the user changes the code or creates code from scratch that is submitted to DevMatch. DevMatch then runs the **evaluator**, which scores the solution based on pre-defined **test cases**. The test cases are returned to the user as a submission score.

::: mermaid
sequenceDiagram
    autonumber
    actor User
    participant DevMatch
    participant Challenge
    User->>DevMatch: Open Problem
    DevMatch->>Challenge: Open Problem
    Note right of Challenge: prerequisites()
    Note right of Challenge: openProblem()
    Note right of Challenge: getProblemStatement()
    Challenge->>DevMatch: Statement
    DevMatch->>User: Statement
    loop SolveProblem
        User->>DevMatch: Submit
        DevMatch->>Challenge: Submit
        Note right of Challenge: getTestCase()
        Note right of Challenge: validate()
        Challenge->>DevMatch: Test cases
        DevMatch->>User: Test cases
    end

:::


# Creating a challenge

## Parts of a problem

You need to define the following:

* An introduction that is 255 characters long.
* A statement.
* A time limit, less than 1 hour.
* A validator.

## Steps
* Prepare
  * Get the job description if you have it
  * Get external source code and make sure you can run it
  * Search online for sample take homes
  * Define skills to assess
  * Define the test cases
* Design the technical implications
  * Consider the verification mechanism. Unit tests? UI tests? Which framework?
  * Remove the boilerplate
  * Remove the external dependencies
* Implement the verification
  * Insert testing framework
  * Write test cases
  * Write the CI pipeline if running in CI/CD build. This also includes publishing artifacts.
  * Write the DevMatch validator
  * put in source code version control
* Integrate with DevMatch
  * Make the UTs output a json that DevMatch can read

## Other considerations

* Installation of dependencies require resources out of the package managers main database?
* For example, installing `dynamodb-local` requires a download from AWS servers, the binary is not in NPM 

## Considerations on using CI
DevMatch can use traditional CI/CD builds to run validators. DevMatch will need to:

* Trigger a build. This means that the definition (usually Yaml) has already been created.
* Add metadata to the build instance; this will be the DevMatch build id.
* Continuously query the state of a given build by ID.
* Fetch artifacts from a finished build.

# Internal notes
[Hannah's framework](https://devmatch.sharepoint.com/:w:/r/sites/DevMatch/_layouts/15/Doc.aspx?sourcedoc=%7BFD30C7A3-00A1-4BA2-80F5-CC46DF7439F6%7D&file=Feedback%20for%20Take-home%20Framework.docx&action=default&mobileredirect=true&cid=c6c3b4e0-109d-4419-999f-b78af9bda7bc) for creating a take-home problem.

Isn't creating problems the same experience as creating a wiki page in Azure DevOps? Backed by git. But editable on the web with minimal burden.


